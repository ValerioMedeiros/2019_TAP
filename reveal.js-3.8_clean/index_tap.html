<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reset.css">
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">
		<!--Aqui muda a cor do fundo-->
		<link rel="stylesheet" href="css/theme/2019_IFRN.css" id="theme">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/monokai.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h2>Outline</h2>
						<div style="flex: 100%">
							<br><br>
							<ol>
								<li> Introduction </li><br>
								<!-- -->
								<li> Features of BTestBox</li><br>
								<li> Example</li><br>
								<li> Related work</li><br>
								<li> Conclusion and future work</li>
							</ol>
						</div>
	
				</section>
				<section>
						<h2>Introduction (1/3)</h2>
						<aside class="notes">
								What is the BTestBox?  
						</aside>
						
						<img src='./img/2019_TAP_Portugal/logo_full_BTestbox_unamed.png' alt='Image' style='height: 20vmin; background: none; text-shadow: none; box-shadow: none; border: none;' />
						<ul>
								<li>It is an <u>open source</u> tool developed to support the <u>validation of code generated</u> from B specifications up to executable code. </li><br>
								<ul>
									<li>Tests the translated code and assures dependability of the translation  according to the coverage criterion. </li><br>
									  <ul>
										  <li> <i>Statement Coverage  <b>(ST)</b>; Branch Coverage <b>(BC)</b>; Path Coverage <b>(PC)</b>; Clause Coverage <b>(CC)</b>;  Combinatorial Coverage <b>(CoC)</b>. </i> [AMMANN, 2003]
											   
											</li>
									  </ul>  <br>
									<!-- <li>May help the verification process to find counterexamples</li>-->
									<li>Can be used as <u>an extension for Atelier B</u> (a popular IDE developed to model, refine, verify, and generate code for B Method). </li>
								</ul>
								
						</ul>
				</section>
				
				<section>
						<h2>Introduction  - B Method (2/3)</h2>
						<br>Sorell M. : 
						
							<ul>
								<li>The B Method is a consolidated formal method that <u>has been used for several years in critical systems</u>. </li>
								<li>It is based on the abstract machine notation <u>(AMN)</u> and on the generalized substitution theory, which was grounded over Dijkstra’s notes [Dijkstra et al. 1976]. </li>
								<li>The B Method supports <u>modular modeling</u>; each module specifies a software component in a different abstraction level. </li>
								<img class="imgsemborda" src="./img/2019_TAP_Portugal/articlefigs/SAC/bmethod.png" style='height: 30vmin; width: auto; background: none; text-shadow: none; box-shadow: none; border: none;'>
								<li>B Method allows to obtain a proven implementation model.</li>
								<ul>
									<li>There is still a weak step in the development process: the production of the binary code from the B implementation.</li>
								</ul>
							</ul>
				</section>
				<section>
					<h2>Motivation (1/2) (General)</h2>
					
					<img class="imgsemborda" src="./img/2019_TAP_Portugal/lupa.png" style='height: 30vmin; width: auto; background: none; text-shadow: none; box-shadow: none; border: none;'>
					<ul>
						<li>Errors in compilers occur and may silently introduce bugs from correct source code [Leroy 2009].</li>
						<li>Even if the source code meets the functional requirements, which is demonstrably the case with the B method, the object code may not meet these requirements. </li>
						<li>Indeed, eleven C compilers are identified with more than 325 compilation errors [Yang et al. 2011]. </li>
						<li>Compilers and translators used in small communities have higher inherent technological risks than tools used in large scale [Stuermer et al. 2007]. </li>
						<ul> <li>B method has a relatively small community.</li>
						</ul>
					</ul>
				</section>
				<section>
						<h2>Motivation (2/2) (B Method)</h2>
						
						<img class="imgsemborda" src="./img/2019_TAP_Portugal/lupa.png" style='height: 30vmin; width: auto; background: none; text-shadow: none; box-shadow: none; border: none;'>
						<ul>
								
							<li>In the B community, these code generators demand additional safety criteria, mainly because they are used in critical applications. </li>
							<li>Testing techniques can be used as an instrument for an in-depth validation of the system.  </li>
							<ul>
								<li>    Also, some certification standards require the use of software testing techniques. </li>
							</ul>
							<li>There are limitations to formal methods, and software testing can complement a formal verification providing tools to identify failures, exploit possible defects introduced during development, or during the maintenance of the code [Matos 2016].  </li>
							<li>This context motived the development of BTestBox.</li>
							</ul>
						</ul>
				</section>
				<section>
					<h2>Creating the test cases</h2>
					<br>
					<ol>
						<li> BTestBox generates <u>a control flow graph</u> and uses Hoare logic to generate a <u>predicate characterizing</u> the possible values for the execution paths, according to the
						chosen criterion.</li>
						<li> Then, the predicates are solved and the values of the input and
						output parameters are stored for each valid solution. </li>
						<ul><li>Our tool prepares B components capable of executing and checking the execution of the test cases after
						the translation.</li></ul>
						<li> Finally, the test components are translated and executed, and
						the metrics are reported.</li>
					</ol>
					<img class="imgsemborda" src="./img/2019_TAP_Portugal/articlefigs/BMethod.png" style='height: 25vmin; width: auto; background: none; text-shadow: none; box-shadow: none; border: none;'>
				</section>
				<section>
						<h2>BTestBox's architecture</h2>
						<div style="display : flex;">
							<div style="flex: 45%">
								<br>
								<ul>
										<li>BTestBox can be used as an <u>extension for Atelier B</u> (a popular IDE developed to model, refine, verify, and generate code for B Method).</li>
										<ul>
											<li>The test cases are written in B so that the models are
												translated and executed in any target language.</li>
											<li>The tool receives a B implementation, the target translator, a compiler, a coverage criterion, the folder project,
												and the logic expression solver (ProB [12])</li>
	
										</ul>
								</ul>
							</div>
							<div style="flex: 55%">
							<img class="imgsemborda" src="./img/2019_TAP_Portugal/articlefigs/SAC/GUI.png" style='height: 40vmin; width: auto; background: none; text-shadow: none; box-shadow: none; border: none;'>
							</div>
						</div>
					</section>
				<section>
					<h2>Example - Path Generation</h2>
					<h4>RussMult</h4>
					<div style="display : flex;">
						<div style="flex: 50%">
							<pre><code data-trim data-noescape>
	IMPLEMENTATION <mark>RussianMult_i</mark>
	REFINES RussianMult
	CONCRETE_VARIABLES xx,yy,total
	INVARIANT xx ∈ N ∧ yy ∈ N ∧
	total ∈ N
	INITIALISATION
		xx,yy,total := 0,0,0
	OPERATIONS
		RussMult(aa,bb) =
			xx:=aa; yy:=bb; total:=0;
			WHILE xx > 0 DO
				IF xx mod 2 = 1 THEN
					total := total + yy 
				END;
				xx := xx / 2; 
				yy := yy * 2
			INVARIANT xx ∈ N ∧
				total+xx*yy = aa * bb
			VARIANT xx
			END
		END
	END
									</code>
							</pre>
							The variant and invariant are necessary to prove the correctness of the operation, including its termination.
						</div>
						<div style="flex: 50%">
							<img class="imgsemborda" src="./img/2019_TAP_Portugal/articlefigs/lacoGrafo.png" style='height: 40vmin; width: auto; background: none; text-shadow: none; box-shadow: none; border: none;'>
							<p> BTestbox generates the following paths:<br>
								<ol>
									<li> = 1, 2, 3, 4, 5, 6, 7, 8, 9, 5, 10; </li>
									<li> = 1, 2, 3, 4, 5, 6,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8, 9, 5, 10; </li>
									<li> = 1, 2, 3, 4, 5,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10.</li>
								</ol></p>
						</div>
					</div>
					<aside class="notes">
						Since the operation has a loop, the graph is cyclic, and contains potentially infinite paths (even though only finite paths are allowed, due to the fact that each loop must terminate in B and has been proved as such). 
					%However, testing uncountable paths is not mechanically possible.
					Instead of repeating the instructions inside the loop and generating different paths for each execution of the loop, \textit{BTestBox} computes the paths inside the loop once and uses them to represent all the paths created with the loop's repetition. 
					We assume this because of the B method termination property - a loop always has to end.
					For our example,
					</aside>   
				</section>
				<section>
					<h3>Generating Predicates</h3>
					We use the notation: \(\{P\} C \{Q\}\), where
					\(P\) represents the precondition for the execution of the command \(C\), and \(Q\) is the post-condition established after the command. 
					\(P\) and \(Q\) are states described by first-order logic formula. 
					The precondition may be computed from the command and post-condition. 
	
					The predicates for each path generated by \textit{BTestBox} are used to create test cases. 
	
					
	
				<aside class="notes">
					Our tool relies on Hoare triples to compute how a command changes the state. 
					We use the notation: \(\{P\} C \{Q\}\), where
					\(P\) represents the precondition for the execution of the command \(C\), and \(Q\) is the post-condition established after the command. 
					\(P\) and \(Q\) are states described by first-order logic formula. 
					The precondition may be computed from the command and post-condition. 
	
				</aside>
	
	
				</section>
				
				<section>
					<h3>Path Generation</h3>
					<p>[TODO: explanation]</p>
					
					<p>
							\(\exists(xx, yy, total).(xx > 0 \wedge xx\ mod\ 2 = 1 \wedge xx \in \mathbb{N} \wedge total + xx * yy = aa * bb) \) <br>
							\(\wedge \)
							\(\exists(xx, yy, total).(xx \leq 0 \wedge xx \in \mathbb{N} \wedge total + xx * yy = aa * bb) \)<br>
							\(\wedge  xx : \mathbb{N} \wedge yy : \mathbb{N} \wedge total : \mathbb{N} \wedge aa : \mathbb{N} \wedge bb : \mathbb{N}   \) 
	
	
					</p>
				   
				</section>
	
	
				<section>
					<h2> Creating test case files</h2>
					<br>
						
							<ul>
								<ul>
									<li>Its improvements will provide interesting information and metrics about the code.</li><br>
								</ul>
								<img class="imgsemborda" src="./img/2019_TAP_Portugal/articlefigs/SAC/arcBTestBox2_new_noBG.png" style='height: 30vmin; width: auto; background: none; text-shadow: none; box-shadow: none; border: none;'><br>
								[TODO: Colocar o relatório do HTML gerado]
							<li>Compatibility to any B Translators (The generated tests are represented on B Language)&#10004;</li>
							</ul>
				</section>
				<section>
					<h2>Experiments</h2>
	
					[TODO: How it was improved?]
					[TODO: Put the table of results]
					
	
				</section>
	
				<section>
					<h2>Related work</h2>
					<ul>
							<li>In [Marinescu et al. 2015], the authors presented an overview of the current state of the art for model-based testing tools that use requirement-based specification languages. </li>
							<li>BZ-TT generates test cases from B and Z models. </li>
									<li>It relies on constraint solving, and its goal is to test every operation. </li>
									<li>It is a private tool and a public version is not available. </li>
							<li>ProTest is an automatic test environment for B specifications. </li>
								<ul>
									<li>It uses model-checking techniques to find test sequences that satisfy its test generation parameters. </li>
									<li>The user has to define the requirements to be satisfied by the test cases. These requirements are operations that must be covered and predicates that must hold true. </li>
									<li>The tool only generates abstract test cases.</li>
									<ul><li>Our tools generate concrete tests.</li></ul>
								</ul>
					</ul>
				</section>
				<section>
						<h2>Related work</h2>
						<ul>
								Tools developed in our research group:
									BETA relies on input space partitioning and logical coverage criteria to generate unit tests from abstract B machines. 
										The tool automates all steps of the test generation process. 
									BTestBox 
										It is completely automatic in all steps of the test generation process based directly on implementation modules which are a closer representation of the actual software. 
										Another difference, it that BETA is focused on unit testing.
										BTestBox tests is focused on the entire module and its functions. 
						</ul>
				</section>
				<section>
					<h2>Extras</h2>

					<a href="index_tap.html?print-pdf"> Export to PDF</a><br>
					<a href="index_tap.html?print-pdf&showNotes=true"> Export to PDF with notes</a>
				</section>
	
			</div>
		</div>

		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true }
				]
			});

			// Shows the slide number using default formatting
			Reveal.configure({ slideNumber: true });

			// Slide number formatting can be configured using these variables:
			//  "h.v": 	horizontal . vertical slide number (default)
			//  "h/v": 	horizontal / vertical slide number
			//    "c": 	flattened slide number
			//  "c/t": 	flattened slide number / total slides
			Reveal.configure({ slideNumber: 'c/t' });

		</script>





	</body>
</html>
